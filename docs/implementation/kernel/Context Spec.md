
**Status:** Draft (implementation-target)  
**Scope:** Kernel / runtime (not business domain)  
**Implementation:** [context.py](../../../src/fund_load/kernel/context.py)  

The **Context** (`Context`, `Ctx`) is a **mutable**, **per-input-event** runtime object that carries execution metadata through the scenario steps.

- **Messages are immutable** (domain/value objects).
- **Context is mutable and short-lived** (exists only while processing one input event).
- Context must not become a “second message” (no business truth inside).

---

## 1. Responsibilities

Context exists to support:

1. **Correlation**
   - `trace_id`, `run_id`, `scenario_id`
   - `line_no` / `offset` to preserve canonical ordering

2. **Runtime bookkeeping**
   - step execution timestamps
   - counters/metrics
   - tags for debugging and trace filtering

3. **Failure recording**
   - structured errors, warnings
   - failure mode flags (e.g., `failed=True`)

4. **Trace tape**
   - step-by-step execution records (owned by kernel)

Context is explicitly **not** responsible for:
- storing business decisions (approve/decline) as canonical truth
- long-lived aggregates (windows, counters) – those belong to `WindowStore`
- cross-event coordination (no global state)

---

## 2. Design invariants

### 2.1 Lifecycle invariant
- A new Context is created **for each raw input event**.
- Context is never reused between events.
- Context is not persisted as a required output artifact.

### 2.2 Mutability invariant
- Steps may mutate Context but must follow **whitelisted namespaces** (see §4).
- The kernel is allowed to mutate Context (trace, timing, step markers).

### 2.3 Minimality invariant
- Context should remain lightweight:
  - mostly small dicts and lists
  - no large blobs; if needed, store **hashes** or **short excerpts**
  - do not store full raw payloads unless specifically enabled for debug

### 2.4 Determinism invariant
- Context must not introduce nondeterminism into business decisions.
- All values that influence decision logic must come from the message or ports, not from “random stuff” in Context.

---

## 3. Core data model

### 3.1 Fields (canonical set)

> Names can be adjusted, but keep semantics stable.

- `trace_id: str`  
  Unique id for this event execution (generated by kernel/context factory). Stable inside the flow.

- `run_id: str`  
  Correlates multiple events processed in the same program run (useful for debugging).

- `scenario_id: str`  
  Which scenario/flow was executed.

- `line_no: int | None`  
  Canonical input order key for NDJSON. Must be set when using file inputs.

- `received_at: datetime`  
  When the runner received the raw event (UTC).

- `tags: dict[str, str]`  
  Debug/correlation labels. Intended for humans and selective tracing (e.g., `customer_id`, `mode=baseline`).

- `metrics: dict[str, float]`  
  Lightweight numeric counters (e.g., durations, counts, watermark-like values).

- `notes: list[str]`  
  Human-friendly notes (e.g., “duplicate id: kept first”).

- `errors: list[CtxError]`  
  Structured errors (see §3.2).

- `trace: list[StepTraceRecord]`  
  Execution tape (see Kernel tracing spec). Context only hosts it.

- `flags: dict[str, bool]`  
  Runtime booleans (e.g., `dropped`, `failed`, `force_decline`).

### 3.2 Error model (`CtxError`)

A context error must be structured and stable.

Required fields:
- `code: str` (machine-readable, e.g., `PARSE_ERROR`, `PORT_FAILURE`)
- `message: str` (short human text)
- `step: str | None` (which step produced it)
- `phase: str` (`ENTER`, `EXEC`, `EXIT`, `COMPOSE`, etc. optional)
- `details: dict[str, object]` (optional; must be JSON-safe)

Rules:
- Do not store exception objects. Store **type name** and **message**, optionally stack in debug mode.

---

## 4. Namespaces and mutation rules

To avoid “context soup”, we define strict namespaces. Steps may only mutate:

### 4.1 `tags`
- only strings
- intended for correlation, not logic
- examples:
  - `tags["customer_id"]="528"`
  - `tags["config_mode"]="exp_mp"`

### 4.2 `metrics`
- floats/ints only
- examples:
  - `metrics["parse_ms"]=1.2`
  - `metrics["attempt_no"]=4`

### 4.3 `notes`
- append-only
- no massive strings; keep each note < ~200 chars
- examples:
  - “idempotency: conflict, routed to conflict stream”

### 4.4 `flags`
- booleans only
- kernel-owned keys:
  - `flags["dropped"]`
  - `flags["failed"]`

### 4.5 `errors`
- append-only list of `CtxError`
- kernel may add error records when catching exceptions

### 4.6 `trace`
- kernel-owned (steps do not write to trace directly)
- steps can influence trace indirectly by mutating allowed keys; kernel snapshots diffs

---

## 5. Context Factory

Context creation is performed by a `ContextFactory` at ingestion time.

### 5.1 Inputs to `ContextFactory`
- raw event
- `line_no` (or offset)
- scenario id
- run id

### 5.2 Outputs
- new Context instance with:
  - generated `trace_id`
  - `received_at` set to `now(UTC)`
  - line/offset populated
  - empty containers

### 5.3 Deterministic trace ids (optional)
For repeatable tests, allow injecting an `IdGenerator` that produces stable ids, e.g.:
- `trace_id = f"t{line_no:06d}"`

---

## 6. Context API helpers (recommended)

We should keep the raw dataclass clean but provide helpers to reduce boilerplate.

### 6.1 Tagging
- `ctx.tag(key, value)`
- `ctx.tag_many(dict)`

### 6.2 Metrics
- `ctx.metric_inc(key, delta=1)`
- `ctx.metric_set(key, value)`

### 6.3 Notes
- `ctx.note(text)`

### 6.4 Errors
- `ctx.error(code, message, step=None, details=None)`

### 6.5 Flags
- `ctx.set_flag(name, value=True)`
- `ctx.is_flag(name)`

All helpers must enforce type constraints.

---

## 7. What Context must *not* contain

These are forbidden patterns:

- Business decision payloads used downstream as truth:
  - do not store `approved=True` as the canonical result
  - do not store computed “effective_amount” in ctx (belongs in message/features)

- Long-lived state:
  - no window sums
  - no “prime used today” counters
  - no caches shared across events

- Arbitrary objects:
  - DB connections
  - file handles
  - sockets
  - exception objects

- Expressions / scripts:
  - no dynamic code

---

## 8. Testing specification

Below are the **required test cases** for Context.  
Use a minimal test framework (`pytest` recommended).  
For each test, build the Context via `ContextFactory` unless specified.

Implementation tests: [tests/stream_kernel/kernel/test_context.py](../../../tests/stream_kernel/kernel/test_context.py)

### 8.1 `test_context_factory_sets_required_fields`
**Given:** raw event + line_no  
**Expect:**
- `trace_id` non-empty string
- `run_id` and `scenario_id` populated (if provided)
- `received_at` is timezone-aware UTC (or normalized)
- `line_no` equals input
- `tags/metrics/notes/errors/trace/flags` are initialized and empty

### 8.2 `test_context_is_unique_per_event`
**Given:** create two contexts for two events  
**Expect:**
- `ctx1 is not ctx2`
- `ctx1.trace_id != ctx2.trace_id` (unless deterministic generator by line_no)

### 8.3 `test_tag_helper_enforces_string_values`
**Given:** `ctx.tag("k", "v")`  
**Expect:** stored correctly  
**And:** `ctx.tag("k", 1)` raises `TypeError` (or returns error record, but choose one and document)

### 8.4 `test_metrics_helper_enforces_numeric_values`
**Given:** `ctx.metric_set("x", 1.0)` ok  
**And:** `ctx.metric_set("x", "1")` fails

### 8.5 `test_notes_are_append_only`
**Given:** `ctx.note("a"); ctx.note("b")`  
**Expect:** `notes == ["a", "b"]`

### 8.6 `test_error_adds_structured_record`
**Given:** `ctx.error("PARSE_ERROR", "bad json", step="ParseLoadAttempt")`  
**Expect:**
- one error
- fields populated
- details default to `{}` if omitted

### 8.7 `test_flags_set_and_read`
**Given:** `ctx.set_flag("dropped")`  
**Expect:** `ctx.is_flag("dropped") is True`

### 8.8 `test_trace_is_kernel_owned`
**Given:** empty ctx  
**When:** step tries to mutate `ctx.trace.append(...)` directly (if step code does that)  
**Expect:** either:
- it is permitted but discouraged, OR
- Context exposes `trace` as read-only / protected
Pick one policy:
- **Recommended for simplicity:** permit but enforce via code review + docs (“kernel owns it”).  
If we enforce, add a wrapper type with restricted API.

### 8.9 `test_context_json_safety_optional`
If we plan to serialize Context for debug:
**Expect:** `ctx.to_json()` returns JSON-safe dict without non-serializable objects.

---

## 9. Open decisions (must be locked before coding)

1. **Type enforcement style**
   - raise exceptions on wrong types
   - or record ctx.error and continue
   Recommended: raise for programmer errors (unit tests catch), record for runtime failures.

2. **Trace mutability**
   - read-only vs normal list
   Recommended: normal list, but only kernel writes.

3. **UTC normalization**
   - require `received_at` in UTC
   - require all timestamps stored as UTC aware datetimes
   Recommended: always UTC aware.

---

## 10. Summary

Context is a **strict, small, per-event runtime object** that enables:
- stable correlation
- reproducible orchestration
- consistent trace recording
- controlled error reporting

It must remain free of business truth and long-lived state.
